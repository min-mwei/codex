<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Vorpal Terminal</title>
    <style>
      :root {
        --bg: #101012;
        --bg-soft: #18181b;
        --input-bg: #0e0e11;
        --fg: #d3d7cf;
        --muted: #8a8f86;
        --accent: #76ff7a;
        --danger: #ff7777;
        --border: #2a2f2f;
        --mono: "JetBrains Mono", "Fira Code", "SFMono-Regular", "Consolas", "Menlo", monospace;
      }

      * {
        box-sizing: border-box;
      }

      html[data-theme="solarized-dark"] {
        --bg: #002b36;
        --bg-soft: #073642;
        --input-bg: #001e26;
        --fg: #93a1a1;
        --muted: #7b8a8b;
        --accent: #2aa198;
        --danger: #dc322f;
        --border: #0f4656;
      }

      html[data-theme="nord"] {
        --bg: #2e3440;
        --bg-soft: #3b4252;
        --input-bg: #262c37;
        --fg: #d8dee9;
        --muted: #a9b5c8;
        --accent: #88c0d0;
        --danger: #bf616a;
        --border: #4c566a;
      }

      html[data-theme="paper-light"] {
        --bg: #f4f0e6;
        --bg-soft: #ebe4d6;
        --input-bg: #fffef8;
        --fg: #2b2b2b;
        --muted: #6c6b68;
        --accent: #00796b;
        --danger: #b23c3c;
        --border: #d4cbb7;
      }

      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
      }

      body {
        overflow: hidden;
        color: var(--fg);
        font-family: var(--mono);
        background: var(--bg);
      }

      .terminal-app {
        display: grid;
        grid-template-rows: auto 1fr auto;
        width: 100vw;
        height: 100vh;
        background: radial-gradient(circle at top right, rgba(255, 255, 255, 0.04), transparent 40%), var(--bg);
      }

      .term-bar {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
        padding: 10px 14px;
        border-bottom: 1px solid var(--border);
        background: var(--bg-soft);
      }

      .window-dots {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .window-dots span {
        width: 11px;
        height: 11px;
        border-radius: 50%;
        border: 1px solid rgba(0, 0, 0, 0.25);
      }

      .window-dots .red {
        background: #ff5f56;
      }

      .window-dots .yellow {
        background: #ffbd2e;
      }

      .window-dots .green {
        background: #27c93f;
      }

      .title-wrap {
        display: inline-flex;
        align-items: center;
        gap: 16px;
        flex: 1;
        min-width: 280px;
      }

      .title {
        color: var(--accent);
        text-transform: lowercase;
        letter-spacing: 0.03em;
      }

      .controls {
        display: inline-flex;
        align-items: center;
        flex-wrap: wrap;
        justify-content: flex-end;
        gap: 8px;
      }

      .control-label {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--muted);
      }

      textarea,
      select,
      button {
        font-family: var(--mono);
      }

      select,
      textarea {
        background: var(--input-bg);
        color: var(--fg);
        border: 1px solid var(--border);
        border-radius: 6px;
        padding: 10px;
        font-size: 13px;
        outline: none;
      }

      select {
        min-width: 150px;
      }

      select:focus,
      textarea:focus {
        border-color: var(--accent);
      }

      button {
        border: 1px solid var(--border);
        padding: 10px 14px;
        border-radius: 6px;
        font-size: 13px;
        background: var(--bg-soft);
        color: var(--fg);
        cursor: pointer;
        transition: border-color 0.15s ease, color 0.15s ease, background-color 0.15s ease;
      }

      button:hover {
        border-color: var(--accent);
        color: var(--accent);
      }

      button.danger {
        color: var(--danger);
      }

      button.danger:hover {
        border-color: var(--danger);
        color: var(--danger);
      }

      .debug-toggle {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--muted);
      }

      .debug-toggle input {
        accent-color: var(--accent);
      }

      .status {
        font-size: 12px;
        color: var(--muted);
        text-transform: lowercase;
      }

      .status[data-state="connected"] {
        color: var(--accent);
      }

      .status[data-state="error"] {
        color: var(--danger);
      }

      .status[data-state="connecting"] {
        color: #ffbd2e;
      }

      .status[data-state="disconnected"] {
        color: var(--danger);
      }

      .log-wrap {
        position: relative;
        overflow: hidden;
      }

      .log-wrap::before {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        background: linear-gradient(to bottom, rgba(255, 255, 255, 0.04) 1px, transparent 1px);
        background-size: 100% 3px;
        opacity: 0.24;
        z-index: 1;
      }

      .log {
        position: relative;
        z-index: 0;
        height: 100%;
        overflow: auto;
        white-space: pre-wrap;
        padding: 14px;
        font-size: 13px;
        line-height: 1.45;
      }

      .log::-webkit-scrollbar {
        width: 10px;
      }

      .log::-webkit-scrollbar-thumb {
        background: var(--border);
      }

      .composer {
        display: grid;
        gap: 8px;
        border-top: 1px solid var(--border);
        background: var(--bg-soft);
        padding: 12px 14px calc(12px + env(safe-area-inset-bottom));
      }

      .input-row {
        display: grid;
        grid-template-columns: auto 1fr auto;
        gap: 10px;
        align-items: end;
      }

      .prompt {
        color: var(--accent);
        font-weight: 700;
        font-size: 16px;
        user-select: none;
        padding-bottom: 8px;
      }

      textarea {
        min-height: 72px;
        max-height: 32vh;
        resize: vertical;
      }

      .hint {
        font-size: 12px;
        color: var(--muted);
      }

      @media (max-width: 900px) {
        .term-bar {
          align-items: stretch;
          justify-content: flex-start;
        }

        .title-wrap {
          min-width: 0;
        }

        .controls {
          justify-content: flex-start;
        }
      }

      @media (max-width: 640px) {
        .input-row {
          grid-template-columns: 1fr auto;
        }

        .prompt {
          display: none;
        }
      }

      @media (max-width: 520px) {
        .input-row {
          grid-template-columns: 1fr;
        }

        #sendBtn {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <main class="terminal-app">
      <header class="term-bar">
        <div class="window-dots" aria-hidden="true">
          <span class="red"></span>
          <span class="yellow"></span>
          <span class="green"></span>
        </div>

        <div class="title-wrap">
          <div class="title">vorpal-cli // ai security agent</div>
          <div id="status" class="status">status: idle</div>
        </div>

        <div class="controls">
          <label class="debug-toggle" for="debugToggle">
            debug
            <input id="debugToggle" type="checkbox" />
          </label>
          <label class="control-label" for="themeSelect">theme</label>
          <select id="themeSelect" aria-label="Color scheme">
            <option value="xterm-dark">XTerm Dark</option>
            <option value="solarized-dark">Solarized Dark</option>
            <option value="nord">Nord</option>
            <option value="paper-light">Paper Light</option>
          </select>
          <button id="initBtn" type="button">New Conversation</button>
          <button id="clearBtn" type="button" class="danger">Clear</button>
        </div>
      </header>

      <section class="log-wrap">
        <div id="log" class="log"></div>
      </section>

      <div class="composer">
        <div class="input-row">
          <div class="prompt">&gt;</div>
          <textarea id="payload" spellcheck="false" placeholder="Type a message..."></textarea>
          <button id="sendBtn" type="button">Send</button>
        </div>
        <div class="hint">Enter send, Shift+Enter newline, ↑/↓ history, Ctrl+A/E/U/K/W, Alt+B/F.</div>
      </div>
    </main>

    <script>
      (() => {
        const sendBtn = document.getElementById("sendBtn");
        const initBtn = document.getElementById("initBtn");
        const clearBtn = document.getElementById("clearBtn");
        const debugToggle = document.getElementById("debugToggle");
        const themeSelect = document.getElementById("themeSelect");
        const payloadInput = document.getElementById("payload");
        const logEl = document.getElementById("log");
        const statusEl = document.getElementById("status");

        let socket = null;
        let nextId = 1;
        let threadId = null;
        let initRequested = false;
        let initialized = false;
        let initRequestId = null;
        let threadRequested = false;
        let threadRequestId = null;
        const pendingInputs = [];
        const logLines = [];
        let streaming = false;
        let streamBuffer = "";
        let streamTimestamp = null;
        let streamLineIndex = null;
        let lastAssistantKey = null;
        let lastAssistantAt = 0;
        let reconnectTimer = null;
        let connectInFlight = false;
        const themeStorageKey = "vorpal-theme";
        const defaultTheme = "xterm-dark";
        const inputHistoryStorageKey = "vorpal-input-history";
        const maxInputHistory = 200;
        let inputHistory = [];
        let historyCursor = 0;
        let historyDraft = "";
        let suppressHistoryInputReset = false;
        const approvalQueue = [];
        let activeApproval = null;

        const isDebug = () => debugToggle && debugToggle.checked;
        const isKnownTheme = (theme) =>
          !!themeSelect && Array.from(themeSelect.options).some((option) => option.value === theme);
        const readStoredTheme = () => {
          try {
            return window.localStorage.getItem(themeStorageKey);
          } catch (_error) {
            // localStorage may be unavailable (private mode or strict browser policies).
            return null;
          }
        };
        const persistTheme = (theme) => {
          try {
            window.localStorage.setItem(themeStorageKey, theme);
          } catch (_error) {
            // Ignore persistence failures; theme still applies for the current session.
          }
        };
        const applyTheme = (theme) => {
          const nextTheme = isKnownTheme(theme) ? theme : defaultTheme;
          document.documentElement.setAttribute("data-theme", nextTheme);
          if (themeSelect && themeSelect.value !== nextTheme) {
            themeSelect.value = nextTheme;
          }
          persistTheme(nextTheme);
        };
        const readStoredInputHistory = () => {
          try {
            const raw = window.localStorage.getItem(inputHistoryStorageKey);
            if (!raw) {
              return [];
            }
            const parsed = JSON.parse(raw);
            if (!Array.isArray(parsed)) {
              return [];
            }
            return parsed
              .filter((value) => typeof value === "string")
              .slice(-maxInputHistory);
          } catch (_error) {
            return [];
          }
        };
        const persistInputHistory = () => {
          try {
            window.localStorage.setItem(inputHistoryStorageKey, JSON.stringify(inputHistory));
          } catch (_error) {
            // Ignore persistence failures; history still works for the current session.
          }
        };
        const setInputValue = (text) => {
          suppressHistoryInputReset = true;
          payloadInput.value = text;
          payloadInput.setSelectionRange(text.length, text.length);
          suppressHistoryInputReset = false;
        };
        const resetHistoryCursor = (draft = payloadInput.value) => {
          historyCursor = inputHistory.length;
          historyDraft = draft;
        };
        const pushInputHistory = (text) => {
          if (!text) {
            return;
          }
          if (inputHistory[inputHistory.length - 1] !== text) {
            inputHistory.push(text);
            if (inputHistory.length > maxInputHistory) {
              inputHistory = inputHistory.slice(-maxInputHistory);
            }
            persistInputHistory();
          }
          resetHistoryCursor("");
        };
        const navigateHistory = (direction) => {
          if (!inputHistory.length) {
            return false;
          }
          if (direction < 0) {
            if (historyCursor === inputHistory.length) {
              historyDraft = payloadInput.value;
            }
            if (historyCursor <= 0) {
              return false;
            }
            historyCursor -= 1;
            setInputValue(inputHistory[historyCursor]);
            return true;
          }
          if (direction > 0) {
            if (historyCursor >= inputHistory.length) {
              return false;
            }
            historyCursor += 1;
            if (historyCursor === inputHistory.length) {
              setInputValue(historyDraft);
            } else {
              setInputValue(inputHistory[historyCursor]);
            }
            return true;
          }
          return false;
        };
        const getSelection = () => {
          const start = payloadInput.selectionStart ?? 0;
          const end = payloadInput.selectionEnd ?? start;
          return { start, end };
        };
        const setSelection = (start, end = start) => {
          payloadInput.setSelectionRange(start, end);
        };
        const replaceSelection = (replacement, start = null, end = null) => {
          const { start: selStart, end: selEnd } = getSelection();
          const from = start == null ? selStart : start;
          const to = end == null ? selEnd : end;
          const next = `${payloadInput.value.slice(0, from)}${replacement}${payloadInput.value.slice(to)}`;
          setInputValue(next);
          const caret = from + replacement.length;
          setSelection(caret, caret);
          resetHistoryCursor(next);
        };
        const previousWordStart = (text, index) => {
          let pos = index;
          while (pos > 0 && /\s/.test(text[pos - 1])) {
            pos -= 1;
          }
          while (pos > 0 && !/\s/.test(text[pos - 1])) {
            pos -= 1;
          }
          return pos;
        };
        const nextWordEnd = (text, index) => {
          let pos = index;
          while (pos < text.length && /\s/.test(text[pos])) {
            pos += 1;
          }
          while (pos < text.length && !/\s/.test(text[pos])) {
            pos += 1;
          }
          return pos;
        };
        const isCaretOnFirstLine = () => {
          const { start } = getSelection();
          return payloadInput.value.slice(0, start).indexOf("\n") === -1;
        };
        const isCaretOnLastLine = () => {
          const { end } = getSelection();
          return payloadInput.value.indexOf("\n", end) === -1;
        };
        const handleReadlineKeybind = (event) => {
          if (event.metaKey) {
            return false;
          }
          const { start, end } = getSelection();
          const value = payloadInput.value;
          const hasSelection = start !== end;

          if (event.ctrlKey && !event.altKey) {
            const key = event.key.toLowerCase();
            if (key === "a") {
              event.preventDefault();
              setSelection(0, 0);
              return true;
            }
            if (key === "e") {
              event.preventDefault();
              setSelection(value.length, value.length);
              return true;
            }
            if (key === "u") {
              event.preventDefault();
              if (hasSelection) {
                replaceSelection("");
              } else {
                replaceSelection("", 0, start);
              }
              return true;
            }
            if (key === "k") {
              event.preventDefault();
              if (hasSelection) {
                replaceSelection("");
              } else {
                replaceSelection("", start, value.length);
              }
              return true;
            }
            if (key === "w") {
              event.preventDefault();
              if (hasSelection) {
                replaceSelection("");
              } else {
                replaceSelection("", previousWordStart(value, start), start);
              }
              return true;
            }
            if (key === "p") {
              event.preventDefault();
              navigateHistory(-1);
              return true;
            }
            if (key === "n") {
              event.preventDefault();
              navigateHistory(1);
              return true;
            }
          }

          if (event.altKey && !event.ctrlKey) {
            const key = event.key.toLowerCase();
            if (key === "b") {
              event.preventDefault();
              const target = previousWordStart(value, start);
              setSelection(target, target);
              return true;
            }
            if (key === "f") {
              event.preventDefault();
              const target = nextWordEnd(value, end);
              setSelection(target, target);
              return true;
            }
          }

          return false;
        };

        const showInterim = false;
        const logSystem = (prefix, line) => {
          if (isDebug()) {
            logLine(prefix, line);
          }
        };

        const defaultWsUrl = (() => {
          if (window.location && window.location.protocol === "https:") {
            return `wss://${window.location.host}`;
          }
          if (window.location && window.location.protocol === "http:") {
            return `ws://${window.location.host}`;
          }
          return "ws://localhost:4501";
        })();

        const wsUrl = defaultWsUrl;

        const renderLog = () => {
          logEl.textContent = logLines.join("\n") + (logLines.length ? "\n" : "");
          logEl.scrollTop = logEl.scrollHeight;
        };

        const logLine = (prefix, line) => {
          const ts = new Date().toISOString();
          logLines.push(`[${ts}] ${prefix} ${line}`);
          renderLog();
        };

        const updateLineAt = (index, line) => {
          if (index == null || index < 0 || index >= logLines.length) {
            logLines.push(line);
          } else {
            logLines[index] = line;
          }
          renderLog();
        };

        const setStatus = (text) => {
          statusEl.textContent = `status: ${text}`;
          statusEl.dataset.state = text.replace(/\.+$/, "").trim().toLowerCase();
        };

        const sendJson = (obj) => {
          if (!socket || socket.readyState !== WebSocket.OPEN) {
            logLine("!!", "socket not open");
            return;
          }
          const jsonLine = JSON.stringify(obj) + "\n";
          socket.send(jsonLine);
          if (isDebug()) {
            logLine(">>", jsonLine.trim());
          }
        };

        const isLegacyApprovalMethod = (method) =>
          method === "execCommandApproval" || method === "applyPatchApproval";

        const approvalDecision = (method, action) => {
          if (isLegacyApprovalMethod(method)) {
            if (action === "accept") return "approved";
            if (action === "acceptForSession") return "approved_for_session";
            if (action === "decline") return "denied";
            return "abort";
          }
          if (action === "accept") return "accept";
          if (action === "acceptForSession") return "acceptForSession";
          if (action === "decline") return "decline";
          return "cancel";
        };

        const approvalSummaryLines = (request) => {
          const params = request.params || {};
          const lines = [];
          if (params.reason) {
            lines.push(`reason: ${params.reason}`);
          }
          if (params.command) {
            lines.push(`command: ${params.command}`);
          }
          if (params.cwd) {
            lines.push(`cwd: ${params.cwd}`);
          }
          if (params.itemId) {
            lines.push(`item: ${params.itemId}`);
          }
          if (params.threadId) {
            lines.push(`thread: ${params.threadId}`);
          }
          if (!lines.length) {
            lines.push(JSON.stringify(params, null, 2));
          }
          return lines.join("\n");
        };

        const approvalPromptForMethod = (method) => {
          if (method === "item/commandExecution/requestApproval" || method === "execCommandApproval") {
            return "command approval required";
          }
          if (method === "item/fileChange/requestApproval" || method === "applyPatchApproval") {
            return "file change approval required";
          }
          return "approval required";
        };

        const logApprovalPrompt = (request) => {
          const method = request.method || "";
          logLine("approval>", approvalPromptForMethod(method));
          const details = approvalSummaryLines(request);
          details
            .split("\n")
            .map((line) => line.trim())
            .filter(Boolean)
            .forEach((line) => logLine("approval>", line));
          logLine("approval>", "choose: 1 accept | 2 accept-for-session | 3 decline | 4 cancel-turn");
        };

        const nextApproval = () => {
          if (activeApproval || !approvalQueue.length) {
            return;
          }
          activeApproval = approvalQueue.shift();
          logLine("approval>", `requested ${activeApproval.method}`);
          logApprovalPrompt(activeApproval);
        };

        const clearApprovals = () => {
          approvalQueue.length = 0;
          activeApproval = null;
        };

        const queueApproval = (request) => {
          approvalQueue.push(request);
          nextApproval();
        };

        const replyApproval = (action) => {
          if (!activeApproval || activeApproval.id == null) {
            return;
          }
          const method = activeApproval.method || "";
          const decision = approvalDecision(method, action);
          sendJson({
            id: activeApproval.id,
            result: { decision },
          });
          logLine("approval>", `${method} -> ${decision}`);
          activeApproval = null;
          nextApproval();
        };

        const actionFromApprovalInput = (text) => {
          if (!text) return null;
          const normalized = text.trim().toLowerCase();
          if (normalized === "1" || normalized === "accept" || normalized === "a") {
            return "accept";
          }
          if (
            normalized === "2" ||
            normalized === "accept for session" ||
            normalized === "accept-for-session" ||
            normalized === "session"
          ) {
            return "acceptForSession";
          }
          if (normalized === "3" || normalized === "decline" || normalized === "deny" || normalized === "d") {
            return "decline";
          }
          if (normalized === "4" || normalized === "cancel" || normalized === "abort" || normalized === "c") {
            return "cancel";
          }
          return null;
        };

        const handleApprovalInput = (text) => {
          if (!activeApproval) {
            return false;
          }
          const action = actionFromApprovalInput(text);
          if (!action) {
            logLine("approval>", "invalid choice. enter 1, 2, 3, or 4.");
            return true;
          }
          replyApproval(action);
          return true;
        };

        const sendFromInput = () => {
          const raw = payloadInput.value;
          if (!raw.trim()) {
            return;
          }
          const text = raw.trim();
          payloadInput.value = "";
          pushInputHistory(text);
          logLine("user>", text);
          if (handleApprovalInput(text)) {
            return;
          }
          pendingInputs.push(text);
          if (!socket || socket.readyState !== WebSocket.OPEN) {
            connect();
            return;
          }
          ensureSession();
          flushInputs();
        };

        const defaultInit = () => ({
          id: nextId++,
          method: "initialize",
          params: {
            clientInfo: {
              name: "vorpal-web",
              title: "Vorpal Web Client",
              version: "0.1.0",
            },
          },
        });

        const ensureSession = () => {
          if (!initRequested) {
            initRequested = true;
            initRequestId = nextId;
            sendJson(defaultInit());
          }
          if (initialized && !threadRequested) {
            threadRequested = true;
            threadRequestId = nextId;
            sendJson({ id: nextId++, method: "thread/start", params: {} });
          }
        };

        const flushInputs = () => {
          if (!threadId) {
            return;
          }
          while (pendingInputs.length) {
            const text = pendingInputs.shift();
            sendJson({
              id: nextId++,
              method: "turn/start",
              params: {
                threadId,
                input: [{ type: "text", text }],
              },
            });
          }
        };

        const beginStream = () => {
          streamTimestamp = new Date().toISOString();
          streamLineIndex = logLines.length;
          logLines.push(`[${streamTimestamp}] assistant> `);
          renderLog();
        };

        const updateStream = () => {
          if (streamLineIndex == null) {
            beginStream();
          }
          const ts = streamTimestamp || new Date().toISOString();
          updateLineAt(streamLineIndex, `[${ts}] assistant> ${streamBuffer}`);
        };

        const endStream = () => {
          streaming = false;
          streamBuffer = "";
          streamTimestamp = null;
          streamLineIndex = null;
        };

        const handleAssistantDelta = (delta) => {
          if (!delta) return;
          if (!streaming) {
            streaming = true;
            streamBuffer = "";
            beginStream();
          }
          streamBuffer += delta;
          updateStream();
        };

        const isDuplicateAssistant = (turnId, message) => {
          const key = `${turnId || "unknown"}|${message}`;
          const now = Date.now();
          if (lastAssistantKey === key && now - lastAssistantAt < 1000) {
            return true;
          }
          lastAssistantKey = key;
          lastAssistantAt = now;
          return false;
        };

        const handleAssistantMessage = (message, turnId = null) => {
          if (!message) return;
          if (isDuplicateAssistant(turnId, message)) {
            return;
          }
          if (streaming) {
            streamBuffer = message;
            updateStream();
            endStream();
          } else {
            logLine("assistant>", message);
          }
        };

        const handleEventMsg = (msg, turnId = null) => {
          if (!msg || !msg.type) {
            return;
          }
          if (msg.type === "agent_message") {
            handleAssistantMessage(msg.message || "", turnId);
            return;
          }
          if (msg.type === "agent_message_delta" || msg.type === "agent_message_content_delta") {
            if (showInterim) {
              handleAssistantDelta(msg.delta || "");
            }
            return;
          }
          if (msg.type === "error" && msg.message) {
            logLine("error", msg.message);
          }
        };

        const isAlreadyInitializedError = (obj) => {
          if (!obj || !obj.error || !obj.error.message) {
            return false;
          }
          return String(obj.error.message).toLowerCase().includes("already initialized");
        };

        const handleIncoming = (line) => {
          if (!line.trim()) return;
          let obj;
          try {
            obj = JSON.parse(line);
          } catch (err) {
            logLine("!!", `invalid JSON from server: ${err.message}`);
            return;
          }
          if (obj.id && obj.id === initRequestId && obj.result) {
            initialized = true;
            logSystem("**", "initialized");
            ensureSession();
            return;
          }
          if (obj.id && obj.id === initRequestId && isAlreadyInitializedError(obj)) {
            initialized = true;
            logSystem("**", "already initialized");
            ensureSession();
            return;
          }
          if (obj.id && obj.id === threadRequestId && obj.result && obj.result.thread) {
            const newThreadId = obj.result.thread.id;
            if (threadId !== newThreadId) {
              threadId = newThreadId;
              logSystem("**", `thread ${threadId} ready`);
            }
            flushInputs();
            return;
          }
          if (obj.result && obj.result.thread && obj.result.thread.id) {
            const newThreadId = obj.result.thread.id;
            if (threadId !== newThreadId) {
              threadId = newThreadId;
              logSystem("**", `thread ${threadId} ready`);
            }
            flushInputs();
            return;
          }
          if (obj.method === "thread/started" && obj.params && obj.params.thread) {
            const newThreadId = obj.params.thread.id;
            if (threadId !== newThreadId) {
              threadId = newThreadId;
              logSystem("**", `thread ${threadId} ready`);
            }
            flushInputs();
            return;
          }
          if (obj.method === "item/agentMessage/delta" && obj.params) {
            if (showInterim) {
              handleAssistantDelta(obj.params.delta || "");
            }
            return;
          }
          if (
            obj.id != null &&
            obj.method &&
            (obj.method === "item/commandExecution/requestApproval" ||
              obj.method === "item/fileChange/requestApproval" ||
              obj.method === "execCommandApproval" ||
              obj.method === "applyPatchApproval")
          ) {
            queueApproval(obj);
            return;
          }
          if (obj.method === "item/completed" && obj.params && obj.params.item) {
            const item = obj.params.item;
            if (item.type === "agentMessage" && item.text) {
              handleAssistantMessage(item.text, obj.params.turnId || null);
              return;
            }
          }
          if (obj.method && obj.method.startsWith("codex/event/")) {
            if (obj.params && obj.params.msg) {
              handleEventMsg(obj.params.msg, obj.params.id || obj.params.turnId || null);
            }
            return;
          }
          if (obj.method) {
            if (isDebug()) {
              logLine("<<", line);
            }
            return;
          }
          if (obj.error && obj.error.message) {
            logLine("error", obj.error.message);
          }
        };

        const resetSessionState = () => {
          initRequested = false;
          initialized = false;
          initRequestId = null;
          threadRequested = false;
          threadRequestId = null;
          threadId = null;
          pendingInputs.length = 0;
          endStream();
          clearApprovals();
        };

        const scheduleReconnect = () => {
          if (reconnectTimer) return;
          reconnectTimer = setTimeout(() => {
            reconnectTimer = null;
            connect();
          }, 1000);
        };

        const connect = () => {
          if (connectInFlight) return;
          if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) {
            return;
          }
          connectInFlight = true;
          setStatus("connecting...");
          socket = new WebSocket(wsUrl);

          socket.addEventListener("open", () => {
            connectInFlight = false;
            setStatus("connected");
            logSystem("--", "connected");
            ensureSession();
            flushInputs();
          });

          socket.addEventListener("close", (event) => {
            connectInFlight = false;
            setStatus("disconnected");
            const reason = event.reason ? ` reason=${event.reason}` : "";
            logSystem("--", `closed code=${event.code}${reason}`);
            resetSessionState();
            scheduleReconnect();
          });

          socket.addEventListener("error", () => {
            connectInFlight = false;
            setStatus("error");
            logLine("!!", "WebSocket error");
          });

          socket.addEventListener("message", (event) => {
            const handleText = (text) => {
              if (!text) return;
              if (text.includes("\n")) {
                text
                  .split("\n")
                  .map((line) => line.trim())
                  .filter(Boolean)
                  .forEach(handleIncoming);
              } else {
                handleIncoming(text.trim());
              }
            };
            if (typeof event.data === "string") {
              handleText(event.data);
              return;
            }
            if (event.data instanceof Blob) {
              event.data.text().then(handleText).catch(() => {
                logLine("!!", "failed to read blob message");
              });
              return;
            }
            if (event.data instanceof ArrayBuffer) {
              handleText(new TextDecoder().decode(event.data));
              return;
            }
            if (ArrayBuffer.isView(event.data)) {
              handleText(new TextDecoder().decode(event.data.buffer));
              return;
            }
            logLine("!!", "unknown message type");
          });
        };

        sendBtn.addEventListener("click", sendFromInput);

        payloadInput.addEventListener("keydown", (event) => {
          if (handleReadlineKeybind(event)) {
            return;
          }
          if (
            event.key === "ArrowUp" &&
            !event.shiftKey &&
            !event.ctrlKey &&
            !event.altKey &&
            !event.metaKey &&
            isCaretOnFirstLine()
          ) {
            if (navigateHistory(-1)) {
              event.preventDefault();
            }
            return;
          }
          if (
            event.key === "ArrowDown" &&
            !event.shiftKey &&
            !event.ctrlKey &&
            !event.altKey &&
            !event.metaKey &&
            isCaretOnLastLine()
          ) {
            if (navigateHistory(1)) {
              event.preventDefault();
            }
            return;
          }
          if (event.key === "Enter" && !event.shiftKey && !event.ctrlKey && !event.altKey && !event.metaKey) {
            event.preventDefault();
            sendFromInput();
          }
        });
        payloadInput.addEventListener("input", () => {
          if (suppressHistoryInputReset) {
            return;
          }
          resetHistoryCursor(payloadInput.value);
        });

        initBtn.addEventListener("click", () => {
          resetSessionState();
          if (!socket || socket.readyState !== WebSocket.OPEN) {
            connect();
            return;
          }
          ensureSession();
        });

        clearBtn.addEventListener("click", () => {
          logLines.length = 0;
          renderLog();
        });

        if (themeSelect) {
          themeSelect.addEventListener("change", () => {
            applyTheme(themeSelect.value);
          });
        }

        applyTheme(readStoredTheme() || defaultTheme);
        inputHistory = readStoredInputHistory();
        payloadInput.value = "";
        resetHistoryCursor("");
        connect();
      })();
    </script>
  </body>
</html>
