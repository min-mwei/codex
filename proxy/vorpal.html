<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Vorpal Terminal</title>
    <style>
      :root {
        --bg: #101012;
        --bg-soft: #18181b;
        --input-bg: #0e0e11;
        --fg: #d3d7cf;
        --muted: #8a8f86;
        --accent: #76ff7a;
        --danger: #ff7777;
        --border: #2a2f2f;
        --mono: "JetBrains Mono", "Fira Code", "SFMono-Regular", "Consolas", "Menlo", monospace;
      }

      * {
        box-sizing: border-box;
      }

      html[data-theme="solarized-dark"] {
        --bg: #002b36;
        --bg-soft: #073642;
        --input-bg: #001e26;
        --fg: #93a1a1;
        --muted: #7b8a8b;
        --accent: #2aa198;
        --danger: #dc322f;
        --border: #0f4656;
      }

      html[data-theme="nord"] {
        --bg: #2e3440;
        --bg-soft: #3b4252;
        --input-bg: #262c37;
        --fg: #d8dee9;
        --muted: #a9b5c8;
        --accent: #88c0d0;
        --danger: #bf616a;
        --border: #4c566a;
      }

      html[data-theme="paper-light"] {
        --bg: #f4f0e6;
        --bg-soft: #ebe4d6;
        --input-bg: #fffef8;
        --fg: #2b2b2b;
        --muted: #6c6b68;
        --accent: #00796b;
        --danger: #b23c3c;
        --border: #d4cbb7;
      }

      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
      }

      body {
        overflow: hidden;
        color: var(--fg);
        font-family: var(--mono);
        background: var(--bg);
      }

      .terminal-app {
        display: grid;
        grid-template-rows: auto 1fr auto;
        width: 100vw;
        height: 100vh;
        background: radial-gradient(circle at top right, rgba(255, 255, 255, 0.04), transparent 40%), var(--bg);
      }

      .term-bar {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
        padding: 10px 14px;
        border-bottom: 1px solid var(--border);
        background: var(--bg-soft);
      }

      .window-dots {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .window-dots span {
        width: 11px;
        height: 11px;
        border-radius: 50%;
        border: 1px solid rgba(0, 0, 0, 0.25);
      }

      .window-dots .red {
        background: #ff5f56;
      }

      .window-dots .yellow {
        background: #ffbd2e;
      }

      .window-dots .green {
        background: #27c93f;
      }

      .title-wrap {
        display: inline-flex;
        align-items: center;
        gap: 16px;
        flex: 1;
        min-width: 280px;
      }

      .title {
        color: var(--accent);
        text-transform: lowercase;
        letter-spacing: 0.03em;
      }

      .controls {
        display: inline-flex;
        align-items: center;
        flex-wrap: wrap;
        justify-content: flex-end;
        gap: 8px;
      }

      .control-label {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--muted);
      }

      textarea,
      select,
      button {
        font-family: var(--mono);
      }

      select,
      textarea {
        background: var(--input-bg);
        color: var(--fg);
        border: 1px solid var(--border);
        border-radius: 6px;
        padding: 10px;
        font-size: 13px;
        outline: none;
      }

      select {
        min-width: 150px;
      }

      select:focus,
      textarea:focus {
        border-color: var(--accent);
      }

      button {
        border: 1px solid var(--border);
        padding: 10px 14px;
        border-radius: 6px;
        font-size: 13px;
        background: var(--bg-soft);
        color: var(--fg);
        cursor: pointer;
        transition: border-color 0.15s ease, color 0.15s ease, background-color 0.15s ease;
      }

      button:hover {
        border-color: var(--accent);
        color: var(--accent);
      }

      button.danger {
        color: var(--danger);
      }

      button.danger:hover {
        border-color: var(--danger);
        color: var(--danger);
      }

      .debug-toggle {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--muted);
      }

      .debug-toggle input {
        accent-color: var(--accent);
      }

      .status {
        font-size: 12px;
        color: var(--muted);
        text-transform: lowercase;
      }

      .status[data-state="connected"] {
        color: var(--accent);
      }

      .status[data-state="error"] {
        color: var(--danger);
      }

      .status[data-state="connecting"] {
        color: #ffbd2e;
      }

      .status[data-state="disconnected"] {
        color: var(--danger);
      }

      .log-wrap {
        position: relative;
        overflow: hidden;
      }

      .log-wrap::before {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        background: linear-gradient(to bottom, rgba(255, 255, 255, 0.04) 1px, transparent 1px);
        background-size: 100% 3px;
        opacity: 0.24;
        z-index: 1;
      }

      .log {
        position: relative;
        z-index: 0;
        height: 100%;
        overflow: auto;
        white-space: pre-wrap;
        padding: 14px;
        font-size: 13px;
        line-height: 1.45;
      }

      .log::-webkit-scrollbar {
        width: 10px;
      }

      .log::-webkit-scrollbar-thumb {
        background: var(--border);
      }

      .composer {
        display: grid;
        gap: 8px;
        border-top: 1px solid var(--border);
        background: var(--bg-soft);
        padding: 12px 14px calc(12px + env(safe-area-inset-bottom));
      }

      .input-row {
        display: grid;
        grid-template-columns: auto 1fr auto;
        gap: 10px;
        align-items: end;
      }

      .prompt {
        color: var(--accent);
        font-weight: 700;
        font-size: 16px;
        user-select: none;
        padding-bottom: 8px;
      }

      textarea {
        min-height: 72px;
        max-height: 32vh;
        resize: vertical;
      }

      .hint {
        font-size: 12px;
        color: var(--muted);
      }

      @media (max-width: 900px) {
        .term-bar {
          align-items: stretch;
          justify-content: flex-start;
        }

        .title-wrap {
          min-width: 0;
        }

        .controls {
          justify-content: flex-start;
        }
      }

      @media (max-width: 640px) {
        .input-row {
          grid-template-columns: 1fr auto;
        }

        .prompt {
          display: none;
        }
      }

      @media (max-width: 520px) {
        .input-row {
          grid-template-columns: 1fr;
        }

        #sendBtn {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <main class="terminal-app">
      <header class="term-bar">
        <div class="window-dots" aria-hidden="true">
          <span class="red"></span>
          <span class="yellow"></span>
          <span class="green"></span>
        </div>

        <div class="title-wrap">
          <div class="title">vorpal-cli // ai security agent</div>
          <div id="status" class="status">status: idle</div>
        </div>

        <div class="controls">
          <label class="debug-toggle" for="debugToggle">
            debug
            <input id="debugToggle" type="checkbox" />
          </label>
          <label class="control-label" for="themeSelect">theme</label>
          <select id="themeSelect" aria-label="Color scheme">
            <option value="xterm-dark">XTerm Dark</option>
            <option value="solarized-dark">Solarized Dark</option>
            <option value="nord">Nord</option>
            <option value="paper-light">Paper Light</option>
          </select>
          <button id="initBtn" type="button">New Conversation</button>
          <button id="clearBtn" type="button" class="danger">Clear</button>
        </div>
      </header>

      <section class="log-wrap">
        <div id="log" class="log"></div>
      </section>

      <div class="composer">
        <div class="input-row">
          <div class="prompt">&gt;</div>
          <textarea id="payload" spellcheck="false" placeholder="Type a message..."></textarea>
          <button id="sendBtn" type="button">Send</button>
        </div>
        <div class="hint">Enter to send. Shift+Enter for a new line.</div>
      </div>
    </main>

    <script>
      (() => {
        const sendBtn = document.getElementById("sendBtn");
        const initBtn = document.getElementById("initBtn");
        const clearBtn = document.getElementById("clearBtn");
        const debugToggle = document.getElementById("debugToggle");
        const themeSelect = document.getElementById("themeSelect");
        const payloadInput = document.getElementById("payload");
        const logEl = document.getElementById("log");
        const statusEl = document.getElementById("status");

        let socket = null;
        let nextId = 1;
        let threadId = null;
        let initRequested = false;
        let initialized = false;
        let initRequestId = null;
        let threadRequested = false;
        let threadRequestId = null;
        const pendingInputs = [];
        const logLines = [];
        let streaming = false;
        let streamBuffer = "";
        let streamTimestamp = null;
        let streamLineIndex = null;
        let lastAssistantKey = null;
        let lastAssistantAt = 0;
        let reconnectTimer = null;
        let connectInFlight = false;
        const themeStorageKey = "vorpal-theme";
        const defaultTheme = "xterm-dark";

        const isDebug = () => debugToggle && debugToggle.checked;
        const isKnownTheme = (theme) =>
          !!themeSelect && Array.from(themeSelect.options).some((option) => option.value === theme);
        const readStoredTheme = () => {
          try {
            return window.localStorage.getItem(themeStorageKey);
          } catch (_error) {
            // localStorage may be unavailable (private mode or strict browser policies).
            return null;
          }
        };
        const persistTheme = (theme) => {
          try {
            window.localStorage.setItem(themeStorageKey, theme);
          } catch (_error) {
            // Ignore persistence failures; theme still applies for the current session.
          }
        };
        const applyTheme = (theme) => {
          const nextTheme = isKnownTheme(theme) ? theme : defaultTheme;
          document.documentElement.setAttribute("data-theme", nextTheme);
          if (themeSelect && themeSelect.value !== nextTheme) {
            themeSelect.value = nextTheme;
          }
          persistTheme(nextTheme);
        };

        const showInterim = false;
        const logSystem = (prefix, line) => {
          if (isDebug()) {
            logLine(prefix, line);
          }
        };

        const defaultWsUrl = (() => {
          if (window.location && window.location.protocol === "https:") {
            return `wss://${window.location.host}`;
          }
          if (window.location && window.location.protocol === "http:") {
            return `ws://${window.location.host}`;
          }
          return "ws://localhost:4501";
        })();

        const wsUrl = defaultWsUrl;

        const renderLog = () => {
          logEl.textContent = logLines.join("\n") + (logLines.length ? "\n" : "");
          logEl.scrollTop = logEl.scrollHeight;
        };

        const logLine = (prefix, line) => {
          const ts = new Date().toISOString();
          logLines.push(`[${ts}] ${prefix} ${line}`);
          renderLog();
        };

        const updateLineAt = (index, line) => {
          if (index == null || index < 0 || index >= logLines.length) {
            logLines.push(line);
          } else {
            logLines[index] = line;
          }
          renderLog();
        };

        const setStatus = (text) => {
          statusEl.textContent = `status: ${text}`;
          statusEl.dataset.state = text.replace(/\.+$/, "").trim().toLowerCase();
        };

        const sendJson = (obj) => {
          if (!socket || socket.readyState !== WebSocket.OPEN) {
            logLine("!!", "socket not open");
            return;
          }
          const jsonLine = JSON.stringify(obj) + "\n";
          socket.send(jsonLine);
          if (isDebug()) {
            logLine(">>", jsonLine.trim());
          }
        };

        const sendFromInput = () => {
          if (!socket || socket.readyState !== WebSocket.OPEN) {
            const raw = payloadInput.value;
            if (!raw.trim()) {
              return;
            }
            const text = raw.trim();
            pendingInputs.push(text);
            payloadInput.value = "";
            logLine("user>", text);
            connect();
            return;
          }
          const raw = payloadInput.value;
          if (!raw.trim()) {
            return;
          }
          const text = raw.trim();
          pendingInputs.push(text);
          payloadInput.value = "";
          logLine("user>", text);
          ensureSession();
          flushInputs();
        };

        const defaultInit = () => ({
          id: nextId++,
          method: "initialize",
          params: {
            clientInfo: {
              name: "vorpal-web",
              title: "Vorpal Web Client",
              version: "0.1.0",
            },
          },
        });

        const ensureSession = () => {
          if (!initRequested) {
            initRequested = true;
            initRequestId = nextId;
            sendJson(defaultInit());
          }
          if (initialized && !threadRequested) {
            threadRequested = true;
            threadRequestId = nextId;
            sendJson({ id: nextId++, method: "thread/start", params: {} });
          }
        };

        const flushInputs = () => {
          if (!threadId) {
            return;
          }
          while (pendingInputs.length) {
            const text = pendingInputs.shift();
            sendJson({
              id: nextId++,
              method: "turn/start",
              params: {
                threadId,
                input: [{ type: "text", text }],
              },
            });
          }
        };

        const beginStream = () => {
          streamTimestamp = new Date().toISOString();
          streamLineIndex = logLines.length;
          logLines.push(`[${streamTimestamp}] assistant> `);
          renderLog();
        };

        const updateStream = () => {
          if (streamLineIndex == null) {
            beginStream();
          }
          const ts = streamTimestamp || new Date().toISOString();
          updateLineAt(streamLineIndex, `[${ts}] assistant> ${streamBuffer}`);
        };

        const endStream = () => {
          streaming = false;
          streamBuffer = "";
          streamTimestamp = null;
          streamLineIndex = null;
        };

        const handleAssistantDelta = (delta) => {
          if (!delta) return;
          if (!streaming) {
            streaming = true;
            streamBuffer = "";
            beginStream();
          }
          streamBuffer += delta;
          updateStream();
        };

        const isDuplicateAssistant = (turnId, message) => {
          const key = `${turnId || "unknown"}|${message}`;
          const now = Date.now();
          if (lastAssistantKey === key && now - lastAssistantAt < 1000) {
            return true;
          }
          lastAssistantKey = key;
          lastAssistantAt = now;
          return false;
        };

        const handleAssistantMessage = (message, turnId = null) => {
          if (!message) return;
          if (isDuplicateAssistant(turnId, message)) {
            return;
          }
          if (streaming) {
            streamBuffer = message;
            updateStream();
            endStream();
          } else {
            logLine("assistant>", message);
          }
        };

        const handleEventMsg = (msg, turnId = null) => {
          if (!msg || !msg.type) {
            return;
          }
          if (msg.type === "agent_message") {
            handleAssistantMessage(msg.message || "", turnId);
            return;
          }
          if (msg.type === "agent_message_delta" || msg.type === "agent_message_content_delta") {
            if (showInterim) {
              handleAssistantDelta(msg.delta || "");
            }
            return;
          }
          if (msg.type === "error" && msg.message) {
            logLine("error", msg.message);
          }
        };

        const isAlreadyInitializedError = (obj) => {
          if (!obj || !obj.error || !obj.error.message) {
            return false;
          }
          return String(obj.error.message).toLowerCase().includes("already initialized");
        };

        const handleIncoming = (line) => {
          if (!line.trim()) return;
          let obj;
          try {
            obj = JSON.parse(line);
          } catch (err) {
            logLine("!!", `invalid JSON from server: ${err.message}`);
            return;
          }
          if (obj.id && obj.id === initRequestId && obj.result) {
            initialized = true;
            logSystem("**", "initialized");
            ensureSession();
            return;
          }
          if (obj.id && obj.id === initRequestId && isAlreadyInitializedError(obj)) {
            initialized = true;
            logSystem("**", "already initialized");
            ensureSession();
            return;
          }
          if (obj.id && obj.id === threadRequestId && obj.result && obj.result.thread) {
            const newThreadId = obj.result.thread.id;
            if (threadId !== newThreadId) {
              threadId = newThreadId;
              logSystem("**", `thread ${threadId} ready`);
            }
            flushInputs();
            return;
          }
          if (obj.result && obj.result.thread && obj.result.thread.id) {
            const newThreadId = obj.result.thread.id;
            if (threadId !== newThreadId) {
              threadId = newThreadId;
              logSystem("**", `thread ${threadId} ready`);
            }
            flushInputs();
            return;
          }
          if (obj.method === "thread/started" && obj.params && obj.params.thread) {
            const newThreadId = obj.params.thread.id;
            if (threadId !== newThreadId) {
              threadId = newThreadId;
              logSystem("**", `thread ${threadId} ready`);
            }
            flushInputs();
            return;
          }
          if (obj.method === "item/agentMessage/delta" && obj.params) {
            if (showInterim) {
              handleAssistantDelta(obj.params.delta || "");
            }
            return;
          }
          if (obj.method === "item/completed" && obj.params && obj.params.item) {
            const item = obj.params.item;
            if (item.type === "agentMessage" && item.text) {
              handleAssistantMessage(item.text, obj.params.turnId || null);
              return;
            }
          }
          if (obj.method && obj.method.startsWith("codex/event/")) {
            if (obj.params && obj.params.msg) {
              handleEventMsg(obj.params.msg, obj.params.id || obj.params.turnId || null);
            }
            return;
          }
          if (obj.method) {
            if (isDebug()) {
              logLine("<<", line);
            }
            return;
          }
          if (obj.error && obj.error.message) {
            logLine("error", obj.error.message);
          }
        };

        const resetSessionState = () => {
          initRequested = false;
          initialized = false;
          initRequestId = null;
          threadRequested = false;
          threadRequestId = null;
          threadId = null;
          pendingInputs.length = 0;
          endStream();
        };

        const scheduleReconnect = () => {
          if (reconnectTimer) return;
          reconnectTimer = setTimeout(() => {
            reconnectTimer = null;
            connect();
          }, 1000);
        };

        const connect = () => {
          if (connectInFlight) return;
          if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) {
            return;
          }
          connectInFlight = true;
          setStatus("connecting...");
          socket = new WebSocket(wsUrl);

          socket.addEventListener("open", () => {
            connectInFlight = false;
            setStatus("connected");
            logSystem("--", "connected");
            ensureSession();
            flushInputs();
          });

          socket.addEventListener("close", (event) => {
            connectInFlight = false;
            setStatus("disconnected");
            const reason = event.reason ? ` reason=${event.reason}` : "";
            logSystem("--", `closed code=${event.code}${reason}`);
            resetSessionState();
            scheduleReconnect();
          });

          socket.addEventListener("error", () => {
            connectInFlight = false;
            setStatus("error");
            logLine("!!", "WebSocket error");
          });

          socket.addEventListener("message", (event) => {
            const handleText = (text) => {
              if (!text) return;
              if (text.includes("\n")) {
                text
                  .split("\n")
                  .map((line) => line.trim())
                  .filter(Boolean)
                  .forEach(handleIncoming);
              } else {
                handleIncoming(text.trim());
              }
            };
            if (typeof event.data === "string") {
              handleText(event.data);
              return;
            }
            if (event.data instanceof Blob) {
              event.data.text().then(handleText).catch(() => {
                logLine("!!", "failed to read blob message");
              });
              return;
            }
            if (event.data instanceof ArrayBuffer) {
              handleText(new TextDecoder().decode(event.data));
              return;
            }
            if (ArrayBuffer.isView(event.data)) {
              handleText(new TextDecoder().decode(event.data.buffer));
              return;
            }
            logLine("!!", "unknown message type");
          });
        };

        sendBtn.addEventListener("click", sendFromInput);

        payloadInput.addEventListener("keydown", (event) => {
          if (event.key === "Enter" && !event.shiftKey) {
            event.preventDefault();
            sendFromInput();
          }
        });

        initBtn.addEventListener("click", () => {
          resetSessionState();
          if (!socket || socket.readyState !== WebSocket.OPEN) {
            connect();
            return;
          }
          ensureSession();
        });

        clearBtn.addEventListener("click", () => {
          logLines.length = 0;
          renderLog();
        });

        if (themeSelect) {
          themeSelect.addEventListener("change", () => {
            applyTheme(themeSelect.value);
          });
        }

        applyTheme(readStoredTheme() || defaultTheme);
        payloadInput.value = "";
        connect();
      })();
    </script>
  </body>
</html>
